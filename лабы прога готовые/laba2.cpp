/**
 * Практическое занятие №2. Побитовые операторы. Директивы препроцессора.
 * Указатели.
 */
using namespace std;
#include <iostream>
#include <string>
#include <cmath>
#define LENGTH(x)(2*M_PI*(x))
#define MAX(a, b)(a>b?a:b)
#define EXCHANGE(X, Y) {int n =X; X=Y; Y=n;}
// #if defined NDEBUG
// #include "1.hewew
// #else
// // #include "2.h"
// #endif

int main()
{
    /**
     * Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
     */

    /**
     * Задание 1.1.
     * 
     * Задайте значение переменной `y`, например, с помощью потока ввода.
     *
     * 1. С помощью побитовых операторов и операторов сдвига выведите значение
     *    переменной `y` на консоль в двоичном виде.
     * 2. Сделайте то же, но пропустив незначащие нули.
     *
     * Например, если `y == 9`, то должно получиться
     * 1. `0 0 0 0 ... 0 0 1 0 0 1` (количество двоичных цифр зависит от
     *    платформы).
     * 2. `1 0 0 1`.
     *
     * Что выведет ваша программа, если ввести отрицательное число? Объясните
     * этот результат.
     */

    {
        {int y;
        std::cout << "1.1 (1) Введите y" << "\n";
        std::cin >> y;
        // std::string text {""};
        //TODO: воздержаться от использования string
        for (int counter = 31; counter >= 0; --counter) {
            int cif = ((y >> counter)&1);
            // std::string z = std::to_string(cif);
            // text.append(z);
            std::cout << cif << " ";
        }
        std::cout << endl;
        }
        //2. без незн нулей

        {int y;
        bool flag = false;
        std::cout << "1.1 (2) Введите y:" << "\n";
        std::cin >> y;
        std::string text;
        for (int counter = 31; counter >= 0; --counter) {
            int cif = ((y >> counter)&1);
            if (cif){
                 flag = true;
                 }
            if (flag){
            // std::string z = std::to_string(cif);
            // text.append(z);
            std::cout << cif << " ";
            }
        }
        std::cout << endl;
        }
    }

    /**
     * Задание 1.2.
     *
     * Дана целая переменная `y`, задайте ее значение, например, с помощью
     * потока ввода.
     *
     * В рамках одного цикла "сдвиньте" все единицы в переменной `y` вправо,
     * обновив тем самым значение этой переменной.
     *
     * Например:
     * было:  0100 1111 0000 0000 0110 1111 0000 0010
     * стало: 0000 0000 0000 0000 0000 1111 1111 1111
     *
     * Выведите переменную на экран в двоичном виде до преобразования и после,
     * используя код из задания 1.1.
     */

    {
        // До преобразования:
        int y;
        std::cout << "1.1 (1) Введите y" << "\n";
        std::cin >> y;
        std::string text;
        //TODO: решить без стринг
        for (int counter = 31; counter >= 0; --counter) {
            int cif = ((y >> counter)&1);
            // std::string z = std::to_string(cif);
            // text.append(z);
            std::cout << cif << " ";
        }
        std::cout << endl;
        
        int count = 0;
    	for (int i = 0; i < 31; ++i) {
        	if (y & (1 << i)) {
            		count++;
        	}
    	}

        int cnt = (1 << count) - 1;
	    std::cout << "стало:  ";
	    for (int i = 31; i >= 0; --i) {
        	std::cout << ((cnt >> i) & 1) << " ";
    	}
    	std::cout << std::endl;
    }

    /**
     * Задание 1.3.
     *
     * Дана целая переменная `y`, задайте ее значение.
     *
     * Напишите код, который с помощью побитовых операций:
     *
     * 1. вычислит `y * 2^n`, где целое `n` (0 <= n < 16) задается отдельно;
     * 2. проверит, делится ли `y` на 2, проверит, делится ли `y` на 4;
     * 3. вычислит целую часть логорифма `y` по основанию 2.
     */

    {
        int y;
        int n = 5;
    	std::cout << "Введите число: "<< '\n';
    	std::cin >> y;

    	// 1. Умножаем на 2^n
    	int result = y << n;
    	std::cout << "y * 2^" << n << " = " << result << std::endl;

        //2. Деление на 2 и деление на 4
        bool ifdelitna2 = (y & 1) == 0;
        bool ifdelitna4 = (y & 3) == 0;
        std::cout << "Число делится на 2: " << (ifdelitna2 ? "да" : "нет") << std::endl;
    	std::cout << "Число делится на 4: " << (ifdelitna4 ? "да" : "нет") << std::endl;

        //3. Целая часть логарифма от 2:
        if (y > 0) {
            // TODO: сделать самостоятельно
            int log_res = (int)log2(y);
            std::cout << "Целая часть логарифма:" << log_res << '\n';
        }
        if (y <= 0) {
            std::cout << "Вы ввели неправильный логарифм";
        }

        int log2_res = 0;
        if (y > 1){
            while (y > 1){
                y /= 2;
                log2_res += 1;
            }
        }
        std::cout  << "Целая часть логарифма по осн 2:" << log2_res << endl;
    }

    /**
     * Задание 1.4.
     *
     * Какие операции следует применить к заданному ниже операнду sNum для
     * того, чтобы переменная sRes приняла требуемое значение? Каждую побитовую
     * операцию можно использовать только 1 раз.
     *
     * Замечание: значения подобраны таким образом, что в каждом случае
     * достаточно использовать один оператор (и при необходимости маску). 
     */

    {
        short sNum = 0x8008; // в двоичном: 10000000 00001000
        short sRes;

        /** sRes == 0x7ff7 */ // в двоичном: 01111111 11110111 --> нужно отрицание
        sRes = ~sNum;
    
        /** sRes == 0x8ff8 */ // в двоичном: 10001111 11111000 --> с помощью or и маски 00001111 11110000(в 16-ричном 0x0ff0)
        sRes = sNum | 0x0ff0;


        /** sRes == 0x0008 */ // в двоичном: 00000000 00001000 --> с помощью оператора and и маски 00000000 00001000(в 16-ричном 0х0008)
        sRes = sNum & 0x0008;

        /** sRes == 0x7f08 */ // в двоичном: 01111111 00001000 --> с помощью оператора xor и маски 11111111 00000000(в 16-ричном 0xff00)
        sRes = sNum ^ 0xff00;

        /** sRes == 0xf001 */ // в двоичном: 11110000 00000001 --> с помощью сдвига вправо на 3 >>
        sRes = sNum >> 3;

        /** sRes == 0x0010 */ // в двоичном: 00000000 00010000 --> с помощью сдвига влево на 1 <<
        sRes = sNum << 1;
    }

    
    /**
     * Задание 2. Директивы препроцессора.
     */

    /**
     * Задание 2.1. Использование "математических" макросов стандартной
     * библиотеки.
     *
     * В заголовочном файле <cmath> (который в свою очередь включает старый
     * файл math.h) определены часто используемые математические константы,
     * например M_PI. Воспользуйтесь этой константой для вычисления длины
     * окружности.
     */

    {
        float radius = 5;
        float circumference = 2* M_PI * radius;
    }
    
    /**
     * Задание 2.2. Макросы с параметрами.
     */

    /**
     * Задание 2.2.1.
     *
     * Напишите свою макроподстановку LENGHT которая вычисляет длину
     * окружности. 
     */

    {
        /** Протестируйте написанный макрос для следующих ситуаций */

        float l1 = LENGTH(1 + 2); // должно быть 18.8495...
        float l2 = 1 / LENGTH(2); // должно быть 0.07957...
        std::cout << l1 << '\n';
        std::cout << l2 << '\n';
    }

    /**
     * Задание 2.2.2.
     * 
     * Определите макрос MAX(A, B) для вычисления б'ольшего значения из двух.
     */

    {
        /**
         * Используйте макрос следующим образом. Следите за изменением значений
         * переменных k, i, j. Объясните результат.
         *
         * Постарайтесь убрать побочные эффекты.
         *
         * Отметьте случаи, когда избежать побочных эффектов невозможно.
         */

        int i = 10, j = 12, k;
        k = MAX(i, j); // 12
        k = MAX(j, i) * 2; // 12 * 2 = 24
        k = MAX(j, i+3); // 13
        k = MAX(i--, j++); // 13(сравнивается 9 и 13)
    }

    /**
     * Задание 2.2.3. 
     *
     * Определите макрос EXCHANGE(X, Y)  для перестановки двух объектов типа
     * int в памяти местами. 
     *
     * Проверьте для приведенного фрагмента. 
     *
     * Подумайте, что будет делать макроподстановка, если переставляемые
     * значения разного типа???
     */

    {
        int x1=1, y1=-1;
        EXCHANGE(x1,y1); // заменит x1 на -1, заменит y1 на 1

        int x2=100, y2=-100;
        EXCHANGE(x2,y2); // заменит x2 на -100, заменит y2 на 100
    }

    /**
     * Задание 2.3. Директивы условной трансляции.
     *
     * Выполняя следующий фрагмент, посмотрите, какое значение принимает
     * переменная iNN. 
     *
     * Что нужно сделать для того, чтобы результат был равен 0? 1? 2?
     */
    {
        int iNN;
#if defined NNN && defined MMM
        iNN = 0;
#elif defined MMM
        iNN = 1;
#elif defined NNN 
        iNN = 2;

#else
        iNN = -1;
#endif
    }
    // iNN принимает значение -1, т.к. после всех проверок мы попадаем на else: где и присваиваем -1
    // чтобы результат был 0, нам нужно определить значение NNN и значение MMM
    // чтобы результат стал 1, нам нужно чтобы было определено только значение MMM
    // чтобы результат стал 2, нам нужно чтобы было определено только значение NNN

    /**
     * Задание 2.4. Задание директив при сборке.
     *
     * При сборке программы компилятором можно установить необходимые
     * макроподстановки с помощью ключа `-D`. Например, чтобы при сборке 
     * была определена директива `A` без значения и директива `B` со значением
     * `1`, надо добавить следующие ключи к команде сборки: `-D A -D B=1`.
     * Таким образом команда сборки будет выглядеть примерно так:
     *
     * `gcc -g -D A -D B=1 lab2.cpp`
     *
     * Уберите из кода определения макросов NNN и MMM из прошлого задания и
     * приведите команды компиляции, которые заставят переменную iNN принять
     * нужное значение. 
     *
     * Проверьте их работоспособность.
     */

    /**
     * Задание 2.5. Сборки "DEBUG" и "RELEASE". Предопределенные макросы
     * компилятора.
     *
     * При отладке удобно выводить дополнительную информацию, которая может
     * мешать в итоговой (релизной) версии программы.
     *
     * Существует стандартный макрос, который принято устанавливать при
     * релизной сборке - `NDEBUG`.
     *
     * С помощью макроса NDEBUG и предопределенных макросов выведите на консоль
     * для отладочной версии информацию о том, что это отладочная сборка, о
     * дате сборки, о имени файла, имени функции и строки. Для релизной сборки
     * такая информация не должна выводиться.
     *
     * Для защиты работы соберите две версии программы: отладочную и итоговую.
     * Чтобы собрать итоговую версию в другом исполняемом файле, используйте 
     * ключ компилятора `-o`, примерно так: 
     *
     * `gcc <ваши опции> -o release.out lab2.cpp`
     */
    {
    #if defined NDEBUG
    //TODO: использовать предопределенные макросы
    std::cout << "-------------------------------" << endl;
    std::cout << "Это отладочная сборка" << endl;
    std::cout << "Дата: "<< __DATE__ << endl;
    std::cout << "Имя файла: " << __FILE__ << endl;
    std::cout << "Строка: " << __LINE__  << endl;
    std::cout << "Имя функции: " << __func__ << endl;
    std::cout << "-------------------------------" << endl;
    #else 
    std::cout << "-------------------------------" << endl;
    std::cout << "Программа запущена в релизной сборке" << endl;
    std::cout << "-------------------------------" << endl;
    #endif


    }
    /**
     * Задание 3.Заголовочные файлы. Директива #include.
     */

    /**
     * Задания 3.1. 
     *
     * Создайте и подключите к проекту два заголовочных файла 1.h и 2.h.
     * 
     * В каждом заголовочном файле объявите перечисление с одинаковыми именами
     * констант, но сопоставьте именованным константам разные значения,
     * например:
     *
     * - 1.h - enum MyEnum{My1, My2, My3};  
     * - 2.h - enum MyEnum{My1=5, My2, My3};
     *
     * С помощью директив условной трансляции в DEBUG-версии пользуйтесь
     * значениями констант из 1.h, а в RELEASE-версии значениями констант из
     * 2.h.
     *
     * Замечание: заголовочные файлы принято подключать в верхней части файла,
     * до любых функций (хотя правила компиляции не запрещают подключить их
     * тут).
     */

    /**
     * Задание 4. Указатели. 
     */

    /**
     * Задание 4.1. 
     * 
     * Объявите объекты разных типов и проинициализируйте их.
     *
     * Объявите указатели соответствующих типов и проинициализируйте их
     * адресами заданных объектов. 
     *
     * Выполняя задание, с помощью отладчика посмотрите, какие значения будут
     * присвоены переменным-указателям и на что эти указатели "указывают".
     */

    {
        int n = 4;
        float fn = 2.3;
        char b = 's';

        int *nn = &n; // 0x7ffd57cec6e8
        float *ffn = &fn; // 0x7ffd57cec6ec
        char *bb = &b; // 0x7ffd57cec6dc

        // при каждой компиляции значения указателей будет меняться, т.к. при каждом запуске переменные занимают
        // место в оперативной памяти, поэтому *nn означает, что мы подставляем вместо значения переменной, ее адрес в памяти
        // то есть переменная nn указывает где лежит в памяти значение 4, амперсант используется как оператор взятия адреса
        // то есть берем ее адрес и присваиваем ее указателю

    }

    /**
     * Задание 4.2.
     *
     * Объявите указатель на тип char и проинициализируйте его адресом
     * строкового литерала. Присвойте переменной типа char значение любого
     * элемента строки.
     *
     * Проверьте - возможно ли присвоить какое-либо значение по адресу,
     * задаваемому указателем?
     */

    {
        const char *str = "Polytech";
        char byk = str[0]; // byk == 'P' str[0] - указатель, где byk мы присваиваем значение 'P'
        // str[0] = 'L'; не получится изменить, т.к. литералы являются const
        

    }

    /**
     * Задание 5. Арифметика указателей. Операция разыменования указателя.
     *
     * Выполните следующий код по строчкам в отладчике, проследите за
     * изменением значений указателей и значений объектов, на которые они
     * указывают. 
     *
     * Интерпретируте наблюдаемые результаты.
     */
    {
        int nAr[3] = {1,3};
        int* pn = &nAr[0]; // (1) Создали указатель pn, который указывает на первый элемент массива nAr (0x7ffdf0a7673c)
        (*pn)++; // (2) Значение на которое указывает указатель увеличили на 1   (0x7ffdf0a7673c)
        pn++; // (3) Указатель pn перемещается по массиву на 1 элемент вперед(т.е. 3) (0x7ffdf0a76740)

        char cAr[] = {'A', 'B', 'C', 'D'};
        char *pc = &cAr[0]; // (A) Создали указатель pc, который указывает на первый элемент массива cAr(0x7fffffffe0d4)
        (*pc) = (*pc) + 5; // (F) значение на которое указывает указатель увеличили на 5 --> переместили на 5 символов вперед (0x7fffffffe0d4) 
        pc = pc + 3; // (D) Указатель pc перемещается по массиву на 3 элемента вперед(т.е D) (0x7fffffffe0d7)   
    
        double dAr[3]={1.0,2.0};
        double *pd1 = &dAr[0];// (1.0) Создали указатель pd1, который указывает на первый элемент массива dAr(0x7ffe5d64a490)
        double *pd2 = pd1; // (1.0) Создали указатель pd2, который указывает на этот же первый элемент массива dAr(имеют одинаковый адрес)(0x7ffe5d64a490)
        (*pd2) += 2; // (3.0) значение на которое указывает указатель увеличили на 2, оставшемся на том же адресе(0x7ffe5d64a490)
        pd2 += 2; // (0) Указатель pd2 перемещается по массиву на 2 вперед, присвоится 0, т.к. элемента там нет(0x7ffe5d64a4a0)

        /** Объясните результат выполнения операции вычитания двух указателей */
        pd1 = &dAr[0];
        pd2 = &dAr[1];
        int nNumber = pd2 - pd1;

        //Вычитается укзатель pd1 из указателя pd2. Операция возвращает
	//кол-во элементов между двумя адресами в массиве. Т.к. pd2 указывает на второй
	 //элемент, а pd1 - на первый, --> разница между адресами у них в 8 байт(размер 1 значения double) результат будет равен 1. nNumber == 1//

        /** 
         * Сравните указатели pd2 и pd1 и с помощью cout выведите результаты
         * сравнения.
         */

        if (pd2 > pd1) {
       		std::cout << "pd2 указывает на элемент после pd1" << std::endl;
   	} else if (pd2 < pd1) {
       		std::cout << "pd2 указывает на элемент перед pd1" << std::endl;
   	} else {
       		std::cout << "pd2 и pd1 указывают на один и тот же элемент" << std::endl;
   	}
    }
/*
    /**
     * Задание 6. Явное преобразование указателя. 
     *
     * Иногда возникает необходимость одни и те же данные интерпретировать
     * по-разному, например, целое можно представить как совокупность четырех
     * байтов и работать с каждым байтом по отдельности. Для этого нужно иметь
     * возможность "указывать" как на целое, так и на байт. 
     * 
     * Следовательно, возникает необходимость явного преобразования указателя. 
     * 
     * Подсказка: для правильной интерпретации этого задания воспользуйтесь
     * возможностями отладчика представлять данные в интересующем Вас виде (в
     * данном случае - в шестнадцатеричном) - для этого можно использовать
     * команду print (p) с указанием шестнадцетиричного формата: `p/x`.
     */

    {
        unsigned int nObject = 0x55667788;
        unsigned int* pnObject = &nObject; // 0x7fffffffdfe0 / 1432778632
        unsigned char* pucObject;
        char cc;

        /**
         * Раскомментировав следующую строчку кода, обратите внимание на
         * сообщение компилятора - он не считает преобразование "легальным"
         * (безопасным)
         */
        // pucObject = static_cast<unsigned char*>(pnObject); invalid ‘static_cast’ from type ‘unsigned int*’ to type ‘unsigned char*’

        /**
         * А такое преобразование - целиком на совести программиста. Его можно
         * применять, только четко представляя себе результат преобразования.
         */
        pucObject = reinterpret_cast<unsigned char*>(pnObject);

        /** Проследите за значениями переменной `cc`. Объясните результаты. */
        cc = pucObject[0]; // -120 '\210' 0x88
        cc = pucObject[1]; // 119 'w' 0x77
        cc = pucObject[2]; // 102 'f' 0x66
        cc = pucObject[3]; // 85 'U' 0x55

        /**
         * Выполните следующие строки, наблюдая за значениями следующих
         * выражений: `cc`, `p` и `*p`.
         *
         * Зафиксируйте и интерпретируйте результаты.
         */
        cc = *(pucObject++); // 0x7fffffffdfe0 -120 ---> 136
        cc = (*pucObject)++; // 0x7fffffffdfe1 119 ---> 120

        cc = ++*(pucObject);
        cc = *(++pucObject);
    }

    /**
     * Задание 7. Void-указатель. 
     */

    /**
     * Задание 7.1.
     * 
     * Выполняя задание, посмотрите - какие значения присваиваются
     * void-указателю.
     *
     * Обратите внимание: средствами отладчика вы не можете посмотреть
     * значения, на которые "указывает" void-указатель.
     */
    {
        void *pVoid;
        int nObject3 = 5;
        char cObject3 = 'A';
        int *pInt = &nObject3;  // 0x7ffe97745c6c
        pVoid = &nObject3; // 0x7ffe97745c6c
        pVoid = &cObject3; // 0x7ffe97745c6b
        pVoid = pInt; // 0x7ffe97745c6c

        /** 
         * Прежде, чем раскомментировать следующую строчку, вспомните: что
         * нужно сделать, чтобы выражение стало корректным?
         * указатели void не могут быть разыменованы. Чтобы распечатать содержимое указателя void,
         *  используется оператор static_cast, который преобразует указатель из типа void* в соответствующий тип данных адреса, который хранит указатель.
         */
        // pInt= static_cast<*int>(pVoid);

    }
    
    /**
     * Что нужно сделать для того, чтобы следующее закомментированное выражение
     * стало корректным?
     *
     * В закоментированной строке необходимо объявить void-указатель.
     */
    {
        const int n = 1;
        const void* pVoid = &n;
    }

    /**
     * Задание 7.2.
     *
     * При выполнении следующего фрагмента посмотрите, какие неприятности могут
     * Вас ожидать при явном приведении типа void-указателя, который в момент
     * времени (1) указывает на double, к типу указателя на int (2).
     */

    {
        double dObject3 = 33.33;
        void* pVoid = &dObject3;  //(1)

        // int nTmp = *(static_cast<int*>(pVoid) ); //(2) 
    }
    /**Потеря точности данных: так как тип void указателя не содержит информации о типе данных,
     на который он указывает, явное приведение его к указателю на int может привести к потере точности данных, если исходный тип данных был double.
     
    Некорректное обращение к памяти: если программа будет пытаться обратиться к значению по адресу, который рассматривается как указатель на int,
     когда на самом деле по этому адресу указывает double, это может привести к ошибкам выполнения и непредсказуемому поведению программы.//

    /**
     * Задание 8. Модификатор const. 
     */

    /**
     * Задание 8.1.
     *
     * В каждом из заданий объявите указатель требуемого вида. 
     *
     * Посредством каждого указателя попробуйте: 
     *
     * - получить значение по адресу;
     * - записать новое значение по адресу;
     * - модифицировать указатель.
     */

    /**
     * Задание 8.1.1. Указатель является константой. 
     */

    {
        int a = 3;
        int* const pa = &a;
        // получим значение по адресу
        int zn = *pa;

        // запишем новое значение по адресу
        *pa = 15;

        // модифицировать не сможем, т.к. указатель - константа


    }
    
    /**
     * Задание 8.1.2. Указываемое значение является константой. 
     */

    {
        int const a = 9;
        const int* pa = &a;
        // получим значение по адресу
        int zn = *pa;

        //запишем новое значение по адресу
        // *pa = 20;
        // новое значение не сможем записать т.к. значение константа

        // модифицируем 
        pa = nullptr;

    }

    /**
     * Задание 8.1.3. И указатель, и указываемое значение являются константами. 
     */

    {
        int const a = 9;
        const int* pa = &a;
        // получим новое значение по адресу
        //TODO: проверить будет ли ошибка 
        //pa = 0 // можно изменять сам указатель но нельзя изменять значение переменной на которую указывает указатель

        // *pa = 12;
        // новое значение не сможем записать т.к. значение константа

        // модифицируем
        // pa = nullptr;
        // модифицировать не получится указатель const

    }

    /**
     * Задание 8.2. Указатель на переменную, объявленную с ключевым словом
     * const. 
     *
     * Объявите указатель и проинициализируйте его выражением - `&nN`.
     */

    {
        const int nN = 1;
        const int* pnN = &nN;
        int adr = *pnN; // получаем значение по адресу
        // *pnN = 13; // записываем новое значение по адресу(не получится, т.к. значение равно const)
        pnN = nullptr; //модифицируем указатель(можем т.к. указатель не const)


    }

    /**
     * Задание 9. Указатели на указатели.
     */

    {
        int n = 1;

        /** 
         * Объявите указатель pn и проинициализируйте его так, чтобы он
         * "указывал" на n. 
         */
        int *pn = &n;

        /** 
         * Объявите указатель ppn и проинициализируйте его так, чтобы он
         * "указывал" на pn. 
         */
        int **ppn = &pn;

        /** 
         * Объявите указатель pppn и проинициализируйте его так, чтобы он
         * "указывал" на ppn. 
         */
        int ***pppn = &ppn;

        /** 
         * С помощью указателей pn, ppn и pppn получите значение объекта n и
         * присвойте его m.
         */

        int m = ***pppn;
    }
    return 0;
}
